# Fsalsupport

[参考](https://github.com/nfs-ganesha/nfs-ganesha/wiki/Fsalsupport#vfs)

## FSAL Documentation

このドキュメントはバージョン2.0以降のNFS Ganeshaに適用されます。
以前のバージョンのサーバーにはFSALの概念がありましたが、ここで説明した機能はありませんでした。
その古いインターフェースは廃止予定で、もう保守も文書化もされていません。

**NOTE:** FSALという言葉は、File System Abstraction Layerの頭字語です。

FSALは動的にロードされる共有オブジェクトライブラリです。
サーバーは、その構成ファイルに定義されているすべてのFSALをロードして初期化します。
サーバーを起動するには、少なくとも1つのFSALがロードおよび初期化されている必要があります。
ほとんどのFSALは、適切な初期化のために設定パラメータを使用または必要とします。
詳細は設定ファイルページをご覧ください。

### Supported FSAL Backends

バージョン2.0のリリース時点で、9つのサポートされているFSALがあります。
実行中のサーバーにそれらのすべてをロードして使用することができます。
それぞれの機能と機能は以下に文書化されています。

#### CEPH

CEPHは、もともとカリフォルニア大学サンタクルーズ校で開発され、現在は [Cephプロジェクト](https://ceph.com/) によってサポートされている分散ファイルシステムです。
このFSALは、分散クラスターと複製機能をFSAL内のpNFS操作に公開するように拡張されたCEPHライブラリーの修正版にリンクしています。

NFS Ganeshaは、このFSALのメタデータサーバーとデータサーバーの両方として動作します。
最初のバージョンはpNFSのファイルレイアウトのみをサポートしますが、他のレイアウトも計画されています。

CEPHライブラリーの修正はまだ上流にマージされていません。
これは進行中のプロセスであり、計画は最終的に上流で必要なサポートを得ることです。

#### GLUSTER

GlusterFSは、Red HatによってFedoraディストリビューションとRed Hat Enterprise Linuxの両方で配布されているファイルシステムです。
このFSALは現時点では実験的ですが、ある時点でGlusterFSチームによって完全にサポートされる予定です。

#### GPFS

GPFSは、IBMによって開発およびサポートされているクラスター化ファイルシステムです。
現在、GPFSと2.0より前のバージョンのサーバーをベースにした製品が出荷されています。
バージョン2.0 FSALはファイルレイアウトpNFSをサポートします。
CEPHと同様に、NFS Ganeshaはメタデータサーバとデータサーバの両方として機能します。

#### HPSS

HPSSは、バックエンドとして、HPSSとも呼ばれる独自のIBMテープライブラリ製品を使用しています。
パリのCEAで使用されていますが、CEA以外ではサポートされていません。

#### LUSTRE

このFSALはそのバックエンドとしてLUSTER分散ファイルシステムを使用します。
現在pNFSをサポートしていませんが、ファイルレイアウトのサポートは将来のバージョンで計画されています。

#### PROXY

PROXY FSALは他のNFSサーバのNFSv4.0クライアントとして動作します。
その用途の1つは、NFSv3および9P（Plan 9リモートファイルシステム）クライアントからNFSv4.0サーバーへのゲートウェイ（プロキシ）として機能することです。
pNFSはサポートされていません。

#### PT

IBMのProtectierアプライアンスで使用するためのこのFSAL。
それはPTサーバーがその最終的な操作を完了することを必要とし、Protectier環境の外での使用を意図していません。

#### VFS

これはガネーシャの主力FSALです。
ファイルハンドルをサポートするPOSIX準拠のオペレーティングシステムをサポートします。
Linuxの場合、2.6.39以降のカーネルで動作するローカルファイルシステムをサポートしています。
それ以前のカーネルではXFSをネイティブにしかサポートできません。
カーネルがファイルハンドルをサポートするのに必要なシステムコールでパッチされていれば、FreeBSD 8.1以降もサポートします。

このFSALはpNFSもサポートしています。
設定ファイルのファイルシステム固有のパラメータによって有効になります。
ファイルシステムのレイアウトを管理するためのシステムコールAPIは、いつかLinuxのメインラインに提出される予定です。

このFSALからのエクスポートに対するXFSサポートは、ファイルシステム固有のパラメータによって設定されます。

#### ZFS

ZFSファイルシステムは、ユーザーモードライブラリを介してLinux上で利用可能です。
このFSALはそのライブラリをバックエンドとして使います。
ストレージプールは、ネイティブLinuxファイルシステム内の通常のファイルです。

### FSAL API

FSAL APIは、コアサーバとFSALのバックエンドファイルシステムサポートを実装する共有オブジェクトライブラリとの間のインタフェースです。
このインタフェースは、LinuxカーネルのVFSレイヤのモデルに沿って定義された一連のデータ構造と関数呼び出しです。
APIはバージョン管理されており、サーバーは初期化時にバージョンの不一致を検出しますが、このインターフェースに対して定義された不変のABIはありません。
新しいバージョンのサーバーは、特定の状況下で古いFSALをロードして使用することができますが、このバージョンのリンケージは、エンタープライズLinuxカーネルがドライバーABIを保証するという意味では保証されません。

インターフェース自体はDoxygenによってソースに広く文書化されています。
明確な説明については、開発者はファイル `src/include/fsal_api.h` にあるその資料を参照する必要があります。
VFS FSALもこのインターフェースのFSAL側のための参照実装です。
以下はAPIの概要です。 詳細はDoxygenの資料にあります。

すべてのオブジェクトは、その親の中のメソッドによって作成されます。
以下の詳細を参照してください。
唯一の例外は、単純な関数呼び出しによってロードされるFSAL自体です。

どのオブジェクトにもreleaseメソッドがあります。
これは、オブジェクトが検索または作成されたときに作成された参照を返します。
オブジェクトが不要になったときにreleaseが呼び出されます。
最後の参照が削除されると、オブジェクトはストレージに返されます。
そのオブジェクトに対する特定のアクションについては、以下を参照してください。

#### The FSAL Object

FSAL自体、その初期化、管理、および削除は、このオブジェクトによって管理されます。
コアはコンフィギュレーションファイルのパラメータに基づいてFSALをロードし、そのロードの一部としてfsalは自分自身をFSALオブジェクトとして登録します。
作成したすべてのエクスポートオブジェクトのリストを管理します。

前述のように、FSALオブジェクト自体は単純な関数呼び出しによって作成されます。
FSALを設定するプロセスは、もう少し複雑です。
次のシーケンスは、FSALをロードして初期化します。

1. load_fsal関数はFSALのロードと初期化を開始します。
    実際の作業は、dlopenシステムライブラリコールによって行われます。
    ロックと状態チェックは、次のステップに安定した環境を提供し、FSALが正しく起動されたことを検証するために使用されます。
1. ロード可能なライブラリの特性を利用します。
    システムのダイナミックローダーは、ローダーが呼び出し元に制御を戻す前の最後のステップとして、実行可能ファイルの .init セクションに定義されているすべての関数を呼び出します。
    これは、C ++グローバルオブジェクトのコンストラクタの実行を管理するために考案されました。
    FSALモジュールを初期化するためにそれを使います。
    この関数は、FSALオブジェクトのプライベートメモリを割り当てて初期化します。
1. FSALイニシャライザ関数は、プライベートリソースの設定に成功するとregister_fsalを呼び出します。
    FSALマネージャ内のこの関数は、アクティブなfsalsのリストに追加することで作業を終了します。
1. 最後のステップは設定ファイルからFSALモジュールを初期化することです。
    init_fsals関数は、ロードされているすべてのFSALモジュールをループ処理し、それらのinit_configメソッドを呼び出します。
    この2段階の初期化は、構成解析プロセスがロードパラメータに遭遇するとすぐにFSALがロードされるが、FSAL自体による構成ファイルのFSAL固有部分の処理のためにロードされるため、必要です。

FSALのreleaseメソッドは、FSALリストからそれを削除し、アドレス空間から共有オブジェクトをアンロードします。
create_exportメソッドは、FSALでサポートされているバックエンドファイルシステムにエクスポートを添付するために使用されます。

#### Export Objects

エクスポートオブジェクトは、構成ファイル内のディレクティブに基づいてfsalによって作成されます。
その結果、エクスポートオブジェクトはエクスポートされたファイルシステムに関連します。
NFSv3エクスポートの場合、このエクスポートへのパスはエクスポートリストに置かれます。
NFSv4 +の場合、エクスポートはジャンクションとして疑似ファイルシステムに付加されます。

エクスポートオブジェクトインスタンスは、参照され現在サーバーコアのメタデータキャッシュでアクティブになっているすべてのファイルシステムオブジェクトのリストを維持します。

オブジェクトハンドルを管理または作成するエクスポートオブジェクトメソッドは2種類あります。
lookup、lookup_path、およびlookup_junctionは、基礎となるファイルシステムを照会し、それらにオブジェクトハンドルを返します。
create_handleもオブジェクトハンドルを返しますが、通常はアクティビティがないためにクライアントがキャッシュから削除されたオブジェクトハンドルの操作を行う場合に使用されます。

2番目のタイプはextract_handleです。
各ファイルシステムバックエンドは独自のファイルハンドルフォーマットを持ち、このメソッドはプロトコルハンドルの不透明な部分を受け取り、それを理解するようになっています。
エクスポートとそのFSALがどのように見えるべきかを知っているからです。

releaseメソッドは、割り当てられたアクティブなオブジェクトハンドルがなくなったエクスポートでのみ正常に呼び出すことができます。

#### Object Handles

ハンドルオブジェクトは、バックエンドファイルシステム内の参照オブジェクトのサーバー表現を保持します。
これらのオブジェクトは、コアのメタデータキャッシュ内のエントリと1対1で関連付けられています。
各オブジェクトは、サーバがそのキャッシュエントリをアクティブに保っている限り、バックエンドの「属性」、開いているファイル記述子、およびそのオブジェクトの他の状態を格納します。
さまざまな方法で、バックエンドファイルシステムのメタデータ、つまりinodeデータをサーバー内の共通のメタデータ構造にマッピングします。


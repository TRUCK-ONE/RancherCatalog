# Nested template definitions

テンプレートを解析するときには、別のテンプレートを定義して、解析中のテンプレートに関連付けることができます。 テンプレート定義は、Goプログラムのグローバル変数と同じように、テンプレートの最上位に表示される必要があります。

そのような定義の構文は、各テンプレート宣言を「定義」および「終了」アクションで囲むことです。

定義アクションは、文字列定数を提供することによって作成中のテンプレートに名前を付けます。 これは簡単な例です：
```
`{{define "T1"}}ONE{{end}}
{{define "T2"}}TWO{{end}}
{{define "T3"}}{{template "T1"}} {{template "T2"}}{{end}}
{{template "T3"}}`
```
これは2つのテンプレート、T1とT2、および実行時に他の2つを呼び出す3番目のT3を定義します。 最後にT3を起動します。 実行すると、このテンプレートはテキストを生成します
```
ONE TWO
```
構造上、テンプレートは1つの関連にのみ存在できます。 テンプレートを複数の関連付けからアドレス指定できるようにする必要がある場合は、テンプレート定義を複数回解析して個別の* Template値を作成するか、またはCloneメソッドまたはAddParseTreeメソッドを使用してコピーする必要があります。

解析は、関連するさまざまなテンプレートを組み立てるために複数回呼び出されることがあります。 ファイルに格納されている関連テンプレートを解析する簡単な方法については、ParseFilesおよびParseGlobの関数とメソッドを参照してください。

テンプレートは直接実行することも、名前で識別される関連テンプレートを実行するExecuteTemplateを介して実行することもできます。 上記の例を呼び出すには、次のように記述します。
```
err := tmpl.Execute(os.Stdout, "no data needed")
if err != nil {
	log.Fatalf("execution failed: %s", err)
}
```
特定のテンプレートを名前で明示的に呼び出す
```
err := tmpl.ExecuteTemplate(os.Stdout, "T2", "no data needed")
if err != nil {
	log.Fatalf("execution failed: %s", err)
}
```
